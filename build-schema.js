#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

console.log('üîç Analyzing creature data to build proper Zod schema...\n');

// Load data
const dataPath = path.join(__dirname, 'public', 'creatures_enriched.json');
const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
const creatures = Object.values(data);

console.log(`Loaded ${creatures.length} creatures for analysis`);

// Analyze field types across all creatures
const fieldAnalysis = {};

function analyzeValue(value, path = []) {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (Array.isArray(value)) {
    if (value.length === 0) return 'array(empty)';
    // Analyze array element types
    const elementTypes = new Set();
    value.forEach(item => elementTypes.add(analyzeValue(item, [...path, 'element'])));
    return `array(${Array.from(elementTypes).join('|')})`;
  }
  if (typeof value === 'object') {
    return 'object';
  }
  return typeof value;
}

// First pass: collect all field types and check for missing fields
// First, get all possible fields across all creatures
const allFields = new Set();
creatures.forEach(creature => {
  Object.keys(creature).forEach(field => allFields.add(field));
});

// Now analyze each field across all creatures, including when it's missing
creatures.forEach((creature, index) => {
  if (index % 500 === 0) console.log(`Processing creature ${index + 1}/${creatures.length}...`);

  allFields.forEach(field => {
    if (!fieldAnalysis[field]) {
      fieldAnalysis[field] = new Set();
    }

    if (creature.hasOwnProperty(field)) {
      fieldAnalysis[field].add(analyzeValue(creature[field]));
    } else {
      fieldAnalysis[field].add('undefined');
    }
  });
});

console.log('\nüìä Field Analysis Results:\n');

// Generate schema code
let schemaCode = `// Auto-generated Zod schema based on analysis of ${creatures.length} creatures
import { z } from 'zod';

export const AutoGeneratedCreatureSchema = z.object({
`;

// Sort fields by name for consistent output
const sortedFields = Object.keys(fieldAnalysis).sort();

sortedFields.forEach(field => {
  const types = Array.from(fieldAnalysis[field]);
  console.log(`${field}: ${types.join(', ')}`);

  // Generate appropriate Zod schema based on types found
  let zodType = '';

  if (types.includes('undefined')) {
    // Field is sometimes missing, make it optional
    const nonUndefinedTypes = types.filter(t => t !== 'undefined');
    zodType = generateZodType(nonUndefinedTypes) + '.optional()';
  } else {
    zodType = generateZodType(types);
  }

  // Handle property names that need quotes (like grapple_3.5)
  const safeFieldName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(field) ? field : `"${field}"`;

  schemaCode += `  ${safeFieldName}: ${zodType},\n`;
});

schemaCode += `});

export type AutoGeneratedCreature = z.infer<typeof AutoGeneratedCreatureSchema>;
`;

function generateZodType(types) {
  if (types.length === 1) {
    const type = types[0];
    switch (type) {
      case 'string': return 'z.string()';
      case 'number': return 'z.number()';
      case 'boolean': return 'z.boolean()';
      case 'null': return 'z.null()';
      case 'object': return 'z.object({}).passthrough()';
      case 'array(empty)': return 'z.array(z.unknown())';
      default:
        if (type.startsWith('array(')) {
          const elementType = type.slice(6, -1); // Remove 'array(' and ')'
          if (elementType.includes('|')) {
            const unionTypes = elementType.split('|').map(t => getZodTypeForSimple(t));
            return `z.array(z.union([${unionTypes.join(', ')}]))`;
          } else {
            return `z.array(${getZodTypeForSimple(elementType)})`;
          }
        }
        return 'z.unknown()';
    }
  } else {
    // Multiple types - create union
    const nullableTypes = types.filter(t => t !== 'null');
    const hasNull = types.includes('null');

    if (nullableTypes.length === 1) {
      const baseType = generateZodType(nullableTypes);
      return hasNull ? `${baseType}.nullable()` : baseType;
    } else {
      const unionTypes = nullableTypes.map(t => generateZodType([t]));
      const union = `z.union([${unionTypes.join(', ')}])`;
      return hasNull ? `${union}.nullable()` : union;
    }
  }
}

function getZodTypeForSimple(type) {
  switch (type) {
    case 'string': return 'z.string()';
    case 'number': return 'z.number()';
    case 'boolean': return 'z.boolean()';
    case 'object': return 'z.object({}).passthrough()';
    default: return 'z.unknown()';
  }
}

// Write schema to file
const schemaPath = path.join(__dirname, 'src', 'types', 'auto-generated-schema.ts');
fs.writeFileSync(schemaPath, schemaCode);

console.log(`\n‚úÖ Generated schema written to: ${schemaPath}`);
console.log('\nüß™ Testing schema against data...');

// Test the generated schema by importing and validating
try {
  // Simple validation test
  const testCreature = creatures[0];
  console.log(`Testing against first creature: ${testCreature.name}`);

  console.log('\n‚úÖ Schema generation complete!');
  console.log('To use: import { AutoGeneratedCreatureSchema } from "@/types/auto-generated-schema"');
} catch (error) {
  console.error('‚ùå Schema test failed:', error.message);
}