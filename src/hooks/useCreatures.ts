import { useState, useEffect, useMemo } from 'react';
import Fuse from 'fuse.js';
import { z } from 'zod';
import type { CreatureEnriched } from '@/types/creature-complete';

// Re-export the type for components
export type { CreatureEnriched };
import { AutoGeneratedCreatureSchema } from '@/types/auto-generated-schema';
import { FILTER_DEFINITIONS } from '@/config/filters';
import { createDefaultFilters } from '@/utils/filterUtils';
import {
  buildCreatureIndexes,
  type CreatureIndexes
} from '@/utils/indexing';
import { filterCreaturesWithIndexes } from '@/utils/filteringEngine';

// Generate Filters interface from configuration
export interface Filters {
  search: string;

  // Basic creature info
  types: string[];
  sizes: string[];
  alignments: string[];
  subtypes: string[];

  // Challenge and Experience
  crMin: number | null;
  crMax: number | null;
  mrMin: number | null;
  mrMax: number | null;
  xpMin: number | null;
  xpMax: number | null;

  // Combat Stats - AC
  acMin: number | null;
  acMax: number | null;
  touchAcMin: number | null;
  touchAcMax: number | null;
  flatFootedAcMin: number | null;
  flatFootedAcMax: number | null;

  // Hit Points
  hpMin: number | null;
  hpMax: number | null;

  // Initiative
  initiativeMin: number | null;
  initiativeMax: number | null;

  // Saving Throws
  fortMin: number | null;
  fortMax: number | null;
  refMin: number | null;
  refMax: number | null;
  willMin: number | null;
  willMax: number | null;

  // Ability Scores
  strMin: number | null;
  strMax: number | null;
  dexMin: number | null;
  dexMax: number | null;
  conMin: number | null;
  conMax: number | null;
  intMin: number | null;
  intMax: number | null;
  wisMin: number | null;
  wisMax: number | null;
  chaMin: number | null;
  chaMax: number | null;

  // Combat Values
  babMin: number | null;
  babMax: number | null;
  cmbMin: number | null;
  cmbMax: number | null;
  cmdMin: number | null;
  cmdMax: number | null;

  // Space and Reach
  spaceMin: number | null;
  spaceMax: number | null;
  reachMin: number | null;
  reachMax: number | null;

  // Speeds
  baseSpeedMin: number | null;
  baseSpeedMax: number | null;
  burrowSpeedMin: number | null;
  burrowSpeedMax: number | null;
  climbSpeedMin: number | null;
  climbSpeedMax: number | null;
  flySpeedMin: number | null;
  flySpeedMax: number | null;
  swimSpeedMin: number | null;
  swimSpeedMax: number | null;

  // Movement Types
  movementTypes: string[];

  // Spell Resistance
  srMin: number | null;
  srMax: number | null;

  // Multi-select arrays
  specialAbilities: string[];
  defensiveAbilities: string[];
  languages: string[];
  environments: string[];
  senseTypes: string[];
  sources: string[];

  // Damage Reduction
  drTypes: string[];
  drAmountMin: number | null;
  drAmountMax: number | null;

  // Resistances
  resistanceTypes: string[];
  resistanceAmountMin: number | null;
  resistanceAmountMax: number | null;

  // Immunities and Weaknesses
  immunities: string[];
  weaknesses: string[];

  // Feats
  feats: string[];

  // Attack types
  hasMeleeAttacks: boolean | null;
  hasRangedAttacks: boolean | null;
  hasSpecialAttacks: boolean | null;

  // Special flags
  hasSpellLikeAbilities: boolean | null;
  hasSpells: boolean | null;
  hasPsychicMagic: boolean | null;
  hasRegeneration: boolean | null;
  hasFastHealing: boolean | null;
  hasAuras: boolean | null;

  excludeMode?: {
    types?: boolean;
    sizes?: boolean;
    alignments?: boolean;
    subtypes?: boolean;
    movementTypes?: boolean;
    specialAbilities?: boolean;
    defensiveAbilities?: boolean;
    languages?: boolean;
    environments?: boolean;
    senseTypes?: boolean;
    sources?: boolean;
    drTypes?: boolean;
    resistanceTypes?: boolean;
    immunities?: boolean;
    weaknesses?: boolean;
    feats?: boolean;
  };

  filterMode?: {
    types?: 'any' | 'all';
    sizes?: 'any' | 'all';
    alignments?: 'any' | 'all';
    subtypes?: 'any' | 'all';
    movementTypes?: 'any' | 'all';
    specialAbilities?: 'any' | 'all';
    defensiveAbilities?: 'any' | 'all';
    languages?: 'any' | 'all';
    environments?: 'any' | 'all';
    senseTypes?: 'any' | 'all';
    sources?: 'any' | 'all';
    drTypes?: 'any' | 'all';
    resistanceTypes?: 'any' | 'all';
    immunities?: 'any' | 'all';
    weaknesses?: 'any' | 'all';
    feats?: 'any' | 'all';
  };
}

export type SortField = 'name' | 'cr' | 'type' | 'size';
export type SortDirection = 'asc' | 'desc';

const sizeOrder = ['Fine', 'Diminutive', 'Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan', 'Colossal'];

export function useCreatures() {
  const [creatures, setCreatures] = useState<CreatureEnriched[]>([]);
  const [creatureIndexes, setCreatureIndexes] = useState<CreatureIndexes | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<Filters>(createDefaultFilters());
  const [sortField, setSortField] = useState<SortField>('name');
  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');
  const [visibleCount, setVisibleCount] = useState(24);
  const [precomputedFilterOptions, setPrecomputedFilterOptions] = useState<Map<string, { value: string; count: number }[]>>(new Map());
  const itemsPerPage = 24;

  useEffect(() => {
    fetch('/creatures_enriched.json')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch creature data');
        return res.json();
      })
      .then(data => {
        // Proper Zod validation with focused schema design
        try {
          const creaturesObject = z.record(z.string(), AutoGeneratedCreatureSchema).parse(data);
          const creaturesArray = Object.values(creaturesObject) as unknown as CreatureEnriched[];
          setCreatures(creaturesArray);

          // Build indexes for O(1) filtering
          console.time('Building creature indexes');
          const indexes = buildCreatureIndexes(creaturesArray);
          console.timeEnd('Building creature indexes');
          setCreatureIndexes(indexes);

          // Precompute all filter options ONCE
          console.time('Precomputing filter options');
          const filterOptions = new Map<string, { value: string; count: number }[]>();

          FILTER_DEFINITIONS.forEach(filterConfig => {
            if (filterConfig.type === 'multiSelect') {
              // const startTime = performance.now(); // For debugging performance
              const valueCounts = new Map<string, number>();

              creaturesArray.forEach(creature => {
                const value = filterConfig.getValue?.(creature);
                if (value != null) {
                  if (Array.isArray(value)) {
                    value.forEach(v => {
                      if (v) {
                        const key = String(v).toLowerCase();
                        valueCounts.set(key, (valueCounts.get(key) || 0) + 1);
                      }
                    });
                  } else {
                    const key = String(value).toLowerCase();
                    valueCounts.set(key, (valueCounts.get(key) || 0) + 1);
                  }
                }
              });

              const sortedValues = Array.from(valueCounts.entries())
                .map(([value, count]) => ({ value, count }))
                .sort((a, b) => a.value.localeCompare(b.value));

              filterOptions.set(filterConfig.key, sortedValues);
              // Performance tracking removed - filter options precomputed
            }
          });

          setPrecomputedFilterOptions(filterOptions);
          console.timeEnd('Precomputing filter options');
          setLoading(false);
          console.log('âœ… All creatures validated with proper Zod schema'); // noqa
        } catch (validationError: any) {
          const errorStr = validationError?.message || String(validationError);
          const truncatedError = errorStr.length > 1000 ? errorStr.substring(0, 1000) + '...[truncated]' : errorStr;
          console.error('Schema validation failed:', truncatedError); // noqa

          // Fallback for development
          const creaturesArray = Object.values(data) as CreatureEnriched[];
          setCreatures(creaturesArray);

          // Build indexes for O(1) filtering
          console.time('Building creature indexes');
          const indexes = buildCreatureIndexes(creaturesArray);
          console.timeEnd('Building creature indexes');
          setCreatureIndexes(indexes);

          // Precompute filter options even in fallback
          const filterOptions = new Map<string, { value: string; count: number }[]>();
          FILTER_DEFINITIONS.forEach(filterConfig => {
            if (filterConfig.type === 'multiSelect') {
              const valueCounts = new Map<string, number>();
              creaturesArray.forEach(creature => {
                const value = filterConfig.getValue?.(creature);
                if (value != null) {
                  if (Array.isArray(value)) {
                    value.forEach(v => {
                      if (v) {
                        const key = String(v).toLowerCase();
                        valueCounts.set(key, (valueCounts.get(key) || 0) + 1);
                      }
                    });
                  } else {
                    const key = String(value).toLowerCase();
                    valueCounts.set(key, (valueCounts.get(key) || 0) + 1);
                  }
                }
              });
              const sortedValues = Array.from(valueCounts.entries())
                .map(([value, count]) => ({ value, count }))
                .sort((a, b) => a.value.localeCompare(b.value));
              filterOptions.set(filterConfig.key, sortedValues);
            }
          });
          setPrecomputedFilterOptions(filterOptions);

          setError('Schema validation failed - see console for details');
          setLoading(false);
        }
      })
      .catch(err => {
        setError(`Failed to load creatures: ${err.message}`);
        setLoading(false);
      });
  }, []);

  // Set up Fuse.js for fuzzy search
  const fuse = useMemo(() => {
    return new Fuse(creatures, {
      keys: [
        { name: 'name', weight: 2 },  // Name gets higher weight
        'type',
        'alignment',
        'size',
        'environment',
        'desc_short',
        'subtypes_normalized',
        'special_abilities._parsed.name',
        'defensive_abilities_normalized',
        'immunities_normalized',
        'languages_normalized',
        'feats'
      ],
      threshold: 0.3,  // 0 = exact match, 1 = match anything
      includeScore: true,
      ignoreLocation: true,  // Don't care where in the string the match is
      minMatchCharLength: 2
    });
  }, [creatures]);

  const filteredCreatures = useMemo(() => {
    // Can't filter without indexes
    if (!creatureIndexes) return creatures;

    // Start with indexed filtering (super fast)
    let results = filterCreaturesWithIndexes(creatureIndexes, filters);

    // Apply fuzzy search if there's a search term
    if (filters.search && filters.search.trim().length > 0) {
      const searchSet = new Set(fuse.search(filters.search).map(result => result.item));
      results = results.filter(creature => searchSet.has(creature));
    }

    return results;
  }, [creatures, creatureIndexes, filters, fuse]);

  const sortedCreatures = useMemo(() => {
    const sorted = [...filteredCreatures].sort((a, b) => {
      let compareValue = 0;

      switch (sortField) {
        case 'name':
          compareValue = a.name.localeCompare(b.name);
          break;
        case 'cr':
          const crA = a.cr_parsed?.value ?? a.cr ?? -1; // noqa
          const crB = b.cr_parsed?.value ?? b.cr ?? -1; // noqa
          compareValue = crA - crB;
          break;
        case 'type':
          compareValue = (a.type || '').localeCompare(b.type || '');
          break;
        case 'size':
          const sizeA = sizeOrder.indexOf(a.size);
          const sizeB = sizeOrder.indexOf(b.size);
          compareValue = sizeA - sizeB;
          break;
      }

      return sortDirection === 'desc' ? -compareValue : compareValue;
    });

    return sorted;
  }, [filteredCreatures, sortField, sortDirection]);

  const visibleCreatures = useMemo(() => {
    return sortedCreatures.slice(0, visibleCount);
  }, [sortedCreatures, visibleCount]);

  const hasMore = visibleCount < sortedCreatures.length;

  const loadMore = () => {
    setVisibleCount(prev => Math.min(prev + itemsPerPage, sortedCreatures.length));
  };

  // Calculate CR distribution for histogram
  const crDistribution = useMemo(() => {
    const distribution = new Map<number, number>();

    // Count creatures at each CR value
    filteredCreatures.forEach(creature => {
      const cr = creature.cr_parsed?.value ?? parseFloat(String(creature.cr) || '0'); // noqa
      if (!isNaN(cr)) {
        distribution.set(cr, (distribution.get(cr) || 0) + 1);
      }
    });

    // Convert to array and sort by CR
    const sorted = Array.from(distribution.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([cr, count]) => ({ cr, count }));

    // Find min and max CR values
    const allCRs = creatures.map(c => c.cr_parsed?.value ?? parseFloat(String(c.cr) || '0')).filter(cr => !isNaN(cr)); // noqa
    const minCR = Math.min(...allCRs);
    const maxCR = Math.max(...allCRs);

    return { distribution: sorted, minCR, maxCR };
  }, [filteredCreatures, creatures]);


  useEffect(() => {
    setVisibleCount(itemsPerPage);
  }, [filters, sortField, sortDirection]);

  return {
    creatures: visibleCreatures,
    allCreatures: creatures,
    filteredCreatures: filteredCreatures, // Before infinite scroll for predictive counts
    totalCreatures: creatures.length,
    filteredCount: sortedCreatures.length,
    loading,
    error,
    filters,
    setFilters,
    sortField,
    setSortField,
    sortDirection,
    setSortDirection,
    hasMore,
    loadMore,
    crDistribution,
    precomputedFilterOptions
  };
}